\documentclass{article}

\begin{document}
\paragraph{(1a)}
(4) AVL trees. 1-2 can only find maxs or mins. 3 can take at worst $O(n)$ time. B-Trees are complicated.

\paragraph{(1b)}
(3) $O(\log N)$.

\paragraph{(1c)}
(3) $O(\log N)$.

\paragraph{(1d)}
(3) $O(\log N)$.

\paragraph{}
Count(l, k) returns the number of keys that satisfy $l <= k <= h$.
\paragraph{(1e)}
(6) RANK(h) - RANK(l) + 1. rank(h) is the number of elements less than h, rank(l) is the number of elements less than l. rank(h) - rank(l) gives us the elements less than h, but greater to or equal than l. Thus we add 1 to add h.

\paragraph{(1f)}
(5) RANK(h) - RANK(l). It's like adding l to the keys, to get RANK(h) - RANK(l) + 1, then removing it.

\paragraph{(1g)}
(5) RANK(h) - RANK(l). Don't add one, because h is not in the count.

\paragraph{(1h)}
(4) RANK(h) - RANK(1).

\paragraph{}
Check 1e-1f by example. For 1e, consider 1, 2, 3, 4, 5, 6, and say we want Count(2, 5). Rank(2) = 1, Rank(5) = 4. Count(2, 5) = 4 = Rank(5) - Rank(2) + 1.
For 1f, consider 1, 3, 4, 5, 6, and say we want Count(2, 5). Rank(2) = 1, Rank(5) = 4, Count(2, 5) = 4-1. For 1g, consider 1, 2, 3, 4, 6, and want count(2, 5).
Rank(5) = 4, Rank(2) = 1, count(2, 5) = 3 = rank(5) - rank(2). Finally, consider 1, 3, 4, 6, 7, and calculate count(2, 5). Rank(2) = 1, Rank(5) = 3, Count(2, 5) = 2
= rank(5) - rank(2).

\paragraph{(1i)}
4. the number of nodes in the subtree rooted at node.

\paragraph{(1j)}
3. $O(\log N)$. There are N elements, so the maximum value of $\gamma$ is N, and that will take $O(\log N)$.

\paragraph{(1k)}
2. 1

\paragraph{(1l)}
3. 3

\paragraph{(1m)}
4. 6

\paragraph{(1n)}
4. 10

\paragraph{(1o)}
1. Insert, true
2. delete, true
3. rotate-left, true
4. rotate-right, true
5. rebalance, false
6. heapify, false

\paragraph{(1p)}
1. O(1).

\paragraph{(1q)}
2. lowest common ancestor

\paragraph{(1r)}
3. $O(\log N)$.

\paragraph{

\end{document}
